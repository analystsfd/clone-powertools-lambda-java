{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>Powertools is a suite of utilities for AWS Lambda Functions that makes tracing with AWS X-Ray, structured logging and creating custom metrics asynchronously easier.</p> <p>Looking for a quick run through of the core utilities?</p> <p>Check out this detailed blog post with a practical example.</p>"},{"location":"#tenets","title":"Tenets","text":"<p>This project separates core utilities that will be available in other runtimes vs general utilities that might not be available across all runtimes.</p> <ul> <li>AWS Lambda only \u2013 We optimise for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported.</li> <li>Eases the adoption of best practices \u2013 The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional.</li> <li>Keep it lean \u2013 Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time.</li> <li>We strive for backwards compatibility \u2013 New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined.</li> <li>We work backwards from the community \u2013 We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs)</li> <li>Idiomatic \u2013 Utilities follow programming language idioms and language-specific best practices.</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Powertools dependencies are available in Maven Central. You can use your favourite dependency management tool to install it</p> <ul> <li>Maven</li> <li>Gradle</li> </ul> <p>Quick hello world examples using SAM CLI</p> <p>You can use SAM to quickly setup a serverless project including AWS Lambda Powertools Java.</p> <pre><code>  sam init --location gh:aws-samples/cookiecutter-aws-sam-powertools-java\n</code></pre> <p>For more information about the project and available options refer to this repository</p> <p>Using Java 9 or later?</p> <p>If you are working with lambda function on runtime Java 9 or later, please refer issue for a workaround.</p> Maven <pre><code>&lt;dependencies&gt;\n...\n    &lt;dependency&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-tracing&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-logging&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-metrics&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n...\n&lt;!-- configure the aspectj-maven-plugin to compile-time weave (CTW) the aws-lambda-powertools-java aspects into your project --&gt;\n&lt;build&gt;\n&lt;plugins&gt;\n...\n        &lt;plugin&gt;\n&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n&lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;1.11&lt;/version&gt;\n&lt;configuration&gt;\n&lt;source&gt;1.8&lt;/source&gt;\n&lt;target&gt;1.8&lt;/target&gt;\n&lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt;\n&lt;aspectLibraries&gt;\n&lt;aspectLibrary&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-tracing&lt;/artifactId&gt;\n&lt;/aspectLibrary&gt;\n&lt;aspectLibrary&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-logging&lt;/artifactId&gt;\n&lt;/aspectLibrary&gt;\n&lt;aspectLibrary&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-metrics&lt;/artifactId&gt;\n&lt;/aspectLibrary&gt;\n&lt;/aspectLibraries&gt;\n&lt;/configuration&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;goals&gt;\n&lt;goal&gt;compile&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n...\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> Gradle <p><pre><code>plugins{\nid 'java'\nid 'aspectj.AspectjGradlePlugin' version '0.0.6'\n}\nrepositories {\njcenter()\n}\ndependencies {\nimplementation 'software.amazon.lambda:powertools-tracing:1.3.0'\naspectpath 'software.amazon.lambda:powertools-tracing:1.3.0'\nimplementation 'software.amazon.lambda:powertools-logging:1.3.0'\naspectpath 'software.amazon.lambda:powertools-logging:1.3.0'\nimplementation 'software.amazon.lambda:powertools-metrics:1.3.0'\naspectpath 'software.amazon.lambda:powertools-metrics:1.3.0'\n}\n</code></pre> Note:</p> <p>Please add <code>aspectjVersion = '1.9.6'</code> to the <code>gradle.properties</code> file. The aspectj plugin works at the moment with gradle 5.x only if you are using <code>java 8</code> as runtime. Please refer to open issue for more details.</p>"},{"location":"#environment-variables","title":"Environment variables","text":"<p>Info</p> <p>Explicit parameters take precedence over environment variables.</p> Environment variable Description Utility POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logging POWERTOOLS_LOG_LEVEL Sets logging level Logging POWERTOOLS_TRACER_CAPTURE_RESPONSE Enables/Disables tracing mode to capture method response Tracing POWERTOOLS_TRACER_CAPTURE_ERROR Enables/Disables tracing mode to capture method error Tracing"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>This project follows Keep a Changelog format for changes and adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#130-2021-03-05","title":"[1.3.0] - 2021-03-05","text":"<ul> <li>Powertools: It now works out of the box with code guru profile handler implementation.</li> <li>Logging: Ability to override object mapper used for logging event. This provides customers ability to customize how and what they want to log from event.</li> <li>Metrics: Module now by default captures AWS Request id as property if used together with Metrics annotation. It will also capture Xray Trace ID as property if tracing is enabled. This ensures good observability and tracing.</li> <li>Metrics:<code>withSingleMetric</code> from `MetricsUtils can now pick the default namespace specified either on Metrics annotation or via POWERTOOLS_METRICS_NAMESPACE env var, without need to specify explicitly for each call.</li> <li>Metrics:<code>Metrics</code> annotation captures metrics even in case of unhandled exception from Lambda function.</li> <li>Docs: Migrated from Gatsby to MKdocs documentation system</li> </ul>"},{"location":"core/logging/","title":"Logging","text":"<p>Logging provides an opinionated logger with output structured as JSON.</p> <p>Key features</p> <ul> <li>Capture key fields from Lambda context, cold start and structures logging output as JSON</li> <li>Log Lambda event when instructed, disabled by default, can be enabled explicitly via annotation param</li> <li>Append additional keys to structured log at any point in time</li> </ul>"},{"location":"core/logging/#initialization","title":"Initialization","text":"<p>Powertools extends the functionality of Log4J. Below is an example <code>log4j2.xml</code> file, with the <code>LambdaJsonLayout</code> configured.</p> log4j2.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration packages=\"com.amazonaws.services.lambda.runtime.log4j2\"&gt;\n&lt;Appenders&gt;\n&lt;Console name=\"JsonAppender\" target=\"SYSTEM_OUT\"&gt;\n&lt;LambdaJsonLayout compact=\"true\" eventEol=\"true\"/&gt;\n&lt;/Console&gt;\n&lt;/Appenders&gt;\n&lt;Loggers&gt;\n&lt;Logger name=\"JsonLogger\" level=\"INFO\" additivity=\"false\"&gt;\n&lt;AppenderRef ref=\"JsonAppender\"/&gt;\n&lt;/Logger&gt;\n&lt;Root level=\"info\"&gt;\n&lt;AppenderRef ref=\"JsonAppender\"/&gt;\n&lt;/Root&gt;\n&lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre> <p>You can also override log level by setting <code>POWERTOOLS_LOG_LEVEL</code> env var. Here is an example using AWS Serverless Application Model (SAM)</p> template.yaml <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: java8\nEnvironment:\nVariables:\nPOWERTOOLS_LOG_LEVEL: DEBUG\nPOWERTOOLS_SERVICE_NAME: example\n</code></pre> <p>You can also explicitly set a service name via <code>POWERTOOLS_SERVICE_NAME</code> env var. This sets service key that will be present across all log statements.</p>"},{"location":"core/logging/#standard-structured-keys","title":"Standard structured keys","text":"<p>Your logs will always include the following keys to your structured logging:</p> Key Type Example Description timestamp String \"2020-05-24 18:17:33,774\" Timestamp of actual log statement level String \"INFO\" Logging level coldStart Boolean true ColdStart value. service String \"payment\" Service name defined. \"service_undefined\" will be used if unknown samplingRate int 0.1 Debug logging sampling rate in percentage e.g. 10% in this case message String \"Collecting payment\" Log statement value. Unserializable JSON values will be casted to string functionName String \"example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" functionVersion String \"12\" functionMemorySize String \"128\" functionArn String \"arn:aws:lambda:eu-west-1:012345678910:function:example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" xray_trace_id String \"1-5759e988-bd862e3fe1be46a994272793\" X-Ray Trace ID when Lambda function has enabled Tracing function_request_id String \"899856cb-83d1-40d7-8611-9e78f15f32f4\"\" AWS Request ID from lambda context"},{"location":"core/logging/#capturing-context-lambda-info","title":"Capturing context Lambda info","text":"<p>You can enrich your structured logs with key Lambda context information via <code>logEvent</code> annotation parameter.  You can also explicitly log any incoming event using <code>logEvent</code> param. Refer Override default object mapper  to customise what is logged.</p> <p>Warning</p> <p>Log event is disabled by default to prevent sensitive info being logged.</p> App.java <pre><code>import org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport software.amazon.lambda.logging.LoggingUtils;\nimport software.amazon.lambda.logging.Logging;\n...\n\n/**\n * Handler for requests to Lambda function.\n */\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\nLogger log = LogManager.getLogger();\n\n@Logging\npublic APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) {\n...\n}\n}\n</code></pre> AppLogEvent.java <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class AppLogEvent implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\nLogger log = LogManager.getLogger();\n\n@Logging(logEvent = true)\npublic APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) {\n...\n}\n}\n</code></pre>"},{"location":"core/logging/#appending-additional-keys","title":"Appending additional keys","text":"<p>You can append your own keys to your existing logs via <code>appendKey</code>.</p> App.java <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\nLogger log = LogManager.getLogger();\n\n@Logging(logEvent = true)\npublic APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) {\n...\nLoggingUtils.appendKey(\"test\", \"willBeLogged\");\n...\n\n...\nMap&lt;String, String&gt; customKeys = new HashMap&lt;&gt;();\ncustomKeys.put(\"test\", \"value\");\ncustomKeys.put(\"test1\", \"value1\");\n\nLoggingUtils.appendKeys(customKeys);\n...\n}\n}\n</code></pre>"},{"location":"core/logging/#override-default-object-mapper","title":"Override default object mapper","text":"<p>You can optionally choose to override default object mapper which is used to serialize lambda function events. You might want to supply custom object mapper in order to control how serialisation is done, for example, when you want to log only specific fields from received event due to security.</p> App.java <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\nLogger log = LogManager.getLogger();\n\nstatic {\nObjectMapper objectMapper = new ObjectMapper();\nLoggingUtils.defaultObjectMapper(objectMapper);\n}\n\n@Logging(logEvent = true)\npublic APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) {\n...\n}\n}\n</code></pre>"},{"location":"core/logging/#sampling-debug-logs","title":"Sampling debug logs","text":"<p>You can dynamically set a percentage of your logs to DEBUG level via env var <code>POWERTOOLS_LOGGER_SAMPLE_RATE</code> or via <code>samplingRate</code> attribute on annotation. </p> <p>Info</p> <p>Configuration on environment variable is given precedence over sampling rate configuration on annotation, provided it's in valid value range.</p> Sampling via annotation attribute <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\nLogger log = LogManager.getLogger();\n\n@Logging(samplingRate = 0.5)\npublic APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) {\n...\n}\n}\n</code></pre> Sampling via environment variable <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: java8\nEnvironment:\nVariables:\nPOWERTOOLS_LOGGER_SAMPLE_RATE: 0.5\n</code></pre>"},{"location":"core/metrics/","title":"Metrics","text":"<p>Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF).</p> <p>These metrics can be visualized through Amazon CloudWatch Console.</p> <p>Key features</p> <ul> <li>Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob).</li> <li>Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc).</li> <li>Metrics are created asynchronously by the CloudWatch service, no custom stacks needed.</li> <li>Context manager to create a one off metric with a different dimension.</li> </ul>"},{"location":"core/metrics/#terminologies","title":"Terminologies","text":"<p>If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility:</p> <ul> <li>Namespace. It's the highest level container that will group multiple metrics from multiple services for a given application, for example <code>ServerlessEcommerce</code>.</li> <li>Dimensions. Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example <code>ColdStart</code> metric by Payment <code>service</code>.</li> </ul> Metric terminology, visually explained"},{"location":"core/metrics/#getting-started","title":"Getting started","text":"<p>Metric has two global settings that will be used across all metrics emitted:</p> Setting Description Environment variable Constructor parameter Metric namespace Logical container where all metrics will be placed e.g. <code>ServerlessAirline</code> <code>POWERTOOLS_METRICS_NAMESPACE</code> <code>namespace</code> Service Optionally, sets service metric dimension across all metrics e.g. <code>payment</code> <code>POWERTOOLS_SERVICE_NAME</code> <code>service</code> <p>Use your application or main service as the metric namespace to easily group all metrics</p> template.yaml <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: java8\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: payment\nPOWERTOOLS_METRICS_NAMESPACE: ServerlessAirline\n</code></pre> MetricsEnabledHandler.java <pre><code>import software.amazon.lambda.powertools.metrics.Metrics;\n\npublic class MetricsEnabledHandler implements RequestHandler&lt;Object, Object&gt; {\n\nMetricsLogger metricsLogger = MetricsUtils.metricsLogger();\n\n@Override\n@Metrics(namespace = \"ExampleApplication\", service = \"booking\")\npublic Object handleRequest(Object input, Context context) {\n...\n}\n}\n</code></pre> <p>You can initialize Metrics anywhere in your code as many times as you need - It'll keep track of your aggregate metrics in memory.</p>"},{"location":"core/metrics/#creating-metrics","title":"Creating metrics","text":"<p>You can create metrics using <code>putMetric</code>, and manually create dimensions for all your aggregate metrics using <code>putDimensions</code>.</p> MetricsEnabledHandler.java <pre><code>import software.amazon.lambda.powertools.metrics.Metrics;\nimport software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;\n\npublic class MetricsEnabledHandler implements RequestHandler&lt;Object, Object&gt; {\n\nMetricsLogger metricsLogger = MetricsUtils.metricsLogger();\n\n@Override\n@Metrics(namespace = \"ExampleApplication\", service = \"booking\")\npublic Object handleRequest(Object input, Context context) {\nmetricsLogger.putDimensions(DimensionSet.of(\"environment\", \"prod\"));\nmetricsLogger.putMetric(\"SuccessfulBooking\", 1, Unit.COUNT);\n...\n}\n}\n</code></pre> <p>The <code>Unit</code> enum facilitate finding a supported metric unit by CloudWatch.</p> <p>Metrics overflow</p> <p>CloudWatch EMF supports a max of 100 metrics. Metrics utility will flush all metrics when adding the 100th metric while subsequent metrics will be aggregated into a new EMF object, for your convenience.</p>"},{"location":"core/metrics/#flushing-metrics","title":"Flushing metrics","text":"<p>The <code>@Metrics</code> annotation validates, serializes, and flushes all your metrics. During metrics validation,  if no metrics are provided no exception will be raised. If metrics are provided, and any of the following criteria are  not met, <code>ValidationException</code> exception will be raised.</p> <p>Metric validation</p> <ul> <li>Maximum of 9 dimensions</li> </ul> <p>If you want to ensure that at least one metric is emitted, you can pass <code>raiseOnEmptyMetrics = true</code> to the @Metrics annotation:</p> MetricsRaiseOnEmpty.java <pre><code>import software.amazon.lambda.powertools.metrics.Metrics;\n\npublic class MetricsRaiseOnEmpty implements RequestHandler&lt;Object, Object&gt; {\n\n@Override\n@Metrics(raiseOnEmptyMetrics = true)\npublic Object handleRequest(Object input, Context context) {\n...\n}\n}\n</code></pre>"},{"location":"core/metrics/#capturing-cold-start-metric","title":"Capturing cold start metric","text":"<p>You can capture cold start metrics automatically with <code>@Metrics</code> via the <code>captureColdStart</code> variable.</p> MetricsColdStart.java <pre><code>import software.amazon.lambda.powertools.metrics.Metrics;\n\npublic class MetricsColdStart implements RequestHandler&lt;Object, Object&gt; {\n\n@Override\n@Metrics(captureColdStart = true)\npublic Object handleRequest(Object input, Context context) {\n...\n}\n}\n</code></pre> <p>If it's a cold start invocation, this feature will:</p> <ul> <li>Create a separate EMF blob solely containing a metric named <code>ColdStart</code></li> <li>Add <code>FunctionName</code> and <code>Service</code> dimensions</li> </ul> <p>This has the advantage of keeping cold start metric separate from your application metrics.</p>"},{"location":"core/metrics/#advanced","title":"Advanced","text":""},{"location":"core/metrics/#adding-metadata","title":"Adding metadata","text":"<p>You can use <code>putMetadata</code> for advanced use cases, where you want to metadata as part of the serialized metrics object.</p> <p>Info</p> <p>This will not be available during metrics visualization, use <code>dimensions</code> for this purpose.</p> App.java <pre><code>import software.amazon.lambda.powertools.metrics.Metrics;\nimport software.amazon.cloudwatchlogs.emf.logger.MetricsLogger;\n\npublic class App implements RequestHandler&lt;Object, Object&gt; {\n\n@Override\n@Metrics(namespace = \"ServerlessAirline\", service = \"payment\")\npublic Object handleRequest(Object input, Context context) {\nmetricsLogger().putMetric(\"CustomMetric1\", 1, Unit.COUNT);\nmetricsLogger().putMetadata(\"booking_id\", \"1234567890\");\n...\n}\n}\n</code></pre> <p>This will be available in CloudWatch Logs to ease operations on high cardinal data.</p>"},{"location":"core/metrics/#overriding-default-dimension-set","title":"Overriding default dimension set","text":"<p>By default, all metrics emitted via module captures <code>Service</code> as one of the default dimension. This is either specified via <code>POWERTOOLS_SERVICE_NAME</code> environment variable or via <code>service</code> attribute on <code>Metrics</code> annotation. If you wish to override the default  Dimension, it can be done via <code>MetricsUtils.defaultDimensionSet()</code>.</p> App.java <pre><code>import software.amazon.lambda.powertools.metrics.Metrics;\nimport static software.amazon.lambda.powertools.metrics.MetricsUtils;\n\npublic class App implements RequestHandler&lt;Object, Object&gt; {\n\nMetricsLogger metricsLogger = MetricsUtils.metricsLogger();\n\nstatic {\nMetricsUtils.defaultDimensionSet(DimensionSet.of(\"CustomDimension\", \"booking\"));\n}\n@Override\n@Metrics(namespace = \"ExampleApplication\", service = \"booking\")\npublic Object handleRequest(Object input, Context context) {\n...\nMetricsUtils.withSingleMetric(\"Metric2\", 1, Unit.COUNT, log -&gt; {});\n}\n}\n</code></pre>"},{"location":"core/metrics/#creating-a-metric-with-a-different-dimension","title":"Creating a metric with a different dimension","text":"<p>CloudWatch EMF uses the same dimensions across all your metrics. Use <code>withSingleMetric</code> if you have a metric that should have different dimensions.</p> <p>Info</p> <p>Generally, this would be an edge case since you pay for unique metric. Keep the following formula in mind: unique metric = (metric_name + dimension_name + dimension_value)</p> App.java <pre><code>import static software.amazon.lambda.powertools.metrics.MetricsUtils.withSingleMetric;\n\npublic class App implements RequestHandler&lt;Object, Object&gt; {\n\n@Override\npublic Object handleRequest(Object input, Context context) {\nwithSingleMetric(\"CustomMetrics2\", 1, Unit.COUNT, \"Another\", (metric) -&gt; {\nmetric.setDimensions(DimensionSet.of(\"AnotherService\", \"CustomService\"));\n});\n}\n}\n</code></pre>"},{"location":"core/tracing/","title":"Tracing","text":"<p>Powertools tracing is an opinionated thin wrapper for AWS X-Ray Java SDK a provides functionality to reduce the overhead of performing common tracing tasks.</p> <p></p> <p>Key Features</p> <ul> <li>Capture cold start as annotation, and responses as well as full exceptions as metadata</li> <li>Helper methods to improve the developer experience of creating new X-Ray subsegments.</li> <li>Better developer experience when developing with multiple threads.</li> <li>Auto patch supported modules by AWS X-Ray</li> </ul> <p>Initialization</p> <p>Before your use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray.</p> <p>Example using AWS Serverless Application Model (SAM)</p> template.yaml <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: java8\n\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: example\n</code></pre> <p>The Powertools service name is used as the X-Ray namespace. This can be set using the environment variable <code>POWERTOOLS_SERVICE_NAME</code></p>"},{"location":"core/tracing/#lambda-handler","title":"Lambda handler","text":"<p>To enable Powertools tracing to your function add the <code>@Tracing annotation to your</code>handleRequest` method or on any method will capture the method as a separate subsegment automatically. You can optionally choose to customize  segment name that appears in traces.</p> Tracing annotation <pre><code>public class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Tracing\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\nbusinessLogic1();\n\nbusinessLogic2();\n}\n\n@Tracing\npublic void businessLogic1(){\n\n}\n\n@Tracing\npublic void businessLogic2(){\n\n}\n}\n</code></pre> Custom Segment names <pre><code>public class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Tracing(segmentName=\"yourCustomName\")\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\n...\n}\n</code></pre> <p>By default, this annotation will automatically record method responses and exceptions. You can change the default behavior by setting the environment variables <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE</code> and <code>POWERTOOLS_TRACER_CAPTURE_ERROR</code> as needed. Optionally, you can override behavior by different supported <code>captureMode</code> to record response, exception or both.</p> <p>Returning sensitive information from your Lambda handler or functions, where <code>Tracing</code> is used?</p> <p>You can disable annotation from capturing their responses and exception as tracing metadata with <code>captureMode=DISABLED</code> or globally by setting environment variables <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE</code> and <code>POWERTOOLS_TRACER_CAPTURE_ERROR</code> to <code>false</code></p> Disable on annotation <pre><code>public class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Tracing(captureMode=CaptureMode.DISABLED)\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\n...\n}\n</code></pre> Disable Globally <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: java8\n\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_TRACER_CAPTURE_RESPONSE: false\nPOWERTOOLS_TRACER_CAPTURE_ERROR: false\n</code></pre>"},{"location":"core/tracing/#annotations-metadata","title":"Annotations &amp; Metadata","text":"<p>Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions.</p> <p>Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional  context for an operation using any native object.</p> Annotations <p>You can add annotations using <code>putAnnotation()</code> method from TracingUtils <pre><code>import software.amazon.lambda.powertools.tracing.Tracing;\nimport software.amazon.lambda.powertools.tracing.TracingUtils;\n\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Tracing\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\nTracingUtils.putAnnotation(\"annotation\", \"value\");\n}\n}\n</code></pre></p> Metadata <p>You can add metadata using <code>putMetadata()</code> method from TracingUtils <pre><code>import software.amazon.lambda.powertools.tracing.Tracing;\nimport software.amazon.lambda.powertools.tracing.TracingUtils;\n\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Tracing\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\nTracingUtils.putMetadata(\"content\", \"value\");\n}\n}\n</code></pre></p>"},{"location":"core/tracing/#utilities","title":"Utilities","text":"<p>Tracing modules comes with certain utility method when you don't want to use annotation for capturing a code block under a subsegment, or you are doing multithreaded programming. Refer examples below.</p> Functional Api <pre><code>import software.amazon.lambda.powertools.tracing.Tracing;\nimport software.amazon.lambda.powertools.tracing.TracingUtils;\n\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\nTracingUtils.withSubsegment(\"loggingResponse\", subsegment -&gt; {\n// Some business logic\n});\nTracingUtils.withSubsegment(\"localNamespace\", \"loggingResponse\", subsegment -&gt; {\n// Some business logic\n});\n}\n}\n</code></pre> Multi Threaded Programming <pre><code>import static software.amazon.lambda.powertools.tracing.TracingUtils.withEntitySubsegment;\n\npublic class App implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\n// Extract existing trace data\nEntity traceEntity = AWSXRay.getTraceEntity();\nThread anotherThread = new Thread(() -&gt; withEntitySubsegment(\"inlineLog\", traceEntity, subsegment -&gt; {\n// Business logic in separate thread\n}));\n}\n}\n</code></pre>"},{"location":"core/tracing/#instrumenting-sdk-clients-and-http-calls","title":"Instrumenting SDK clients and HTTP calls","text":"<p>User should make sure to instrument the SDK clients explicitly based on the function dependency. Refer details on how to instrument SDK client with Xray and outgoing http calls.</p>"},{"location":"utilities/batch/","title":"SQS Batch Processing","text":"<p>The SQS batch processing utility provides a way to handle partial failures when processing batches of messages from SQS.</p> <p>Key Features</p> <ul> <li>Prevent successfully processed messages from being returned to SQS</li> <li>A simple interface for individually processing messages from a batch</li> </ul> <p>Background</p> <p>When using SQS as a Lambda event source mapping, Lambda functions can be triggered with a batch of messages from SQS.  If your function fails to process any message from the batch, the entire batch returns to your SQS queue, and your  Lambda function will be triggered with the same batch again. With this utility, messages within a batch will be handled individually - only messages that were not successfully processed are returned to the queue.</p> <p>Warning</p> <p>While this utility lowers the chance of processing messages more than once, it is not guaranteed. We recommend implementing processing logic in an idempotent manner wherever possible. More details on how Lambda works with SQS can be found in the AWS documentation</p>"},{"location":"utilities/batch/#install","title":"Install","text":"<p>To install this utility, add the following dependency to your project.</p> <p>Using Java 9 or later?</p> <p>If you are working with lambda function on runtime Java 9 or later, please refer issue for a workaround.</p> Maven <pre><code>&lt;dependencies&gt;\n...\n    &lt;dependency&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-sqs&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n&lt;!-- configure the aspectj-maven-plugin to compile-time weave (CTW) the aws-lambda-powertools-java aspects into your project --&gt;\n&lt;build&gt;\n&lt;plugins&gt;\n...\n        &lt;plugin&gt;\n&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n&lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;1.11&lt;/version&gt;\n&lt;configuration&gt;\n&lt;source&gt;1.8&lt;/source&gt;\n&lt;target&gt;1.8&lt;/target&gt;\n&lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt;\n&lt;aspectLibraries&gt;\n&lt;aspectLibrary&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-sqs&lt;/artifactId&gt;\n&lt;/aspectLibrary&gt;\n&lt;/aspectLibraries&gt;\n&lt;/configuration&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;goals&gt;\n&lt;goal&gt;compile&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n...\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> Gradle <pre><code> dependencies {\n...\nimplementation 'software.amazon.lambda:powertools-sqs:1.3.0'\naspectpath 'software.amazon.lambda:powertools-sqs:1.3.0'\n}\n</code></pre> <p>IAM Permissions</p> <p>This utility requires additional permissions to work as expected. Lambda functions using this utility require the <code>sqs:GetQueueUrl</code> and <code>sqs:DeleteMessageBatch</code> permission.</p>"},{"location":"utilities/batch/#processing-messages-from-sqs","title":"Processing messages from SQS","text":"<p>You can use either SqsBatch annotation, or SqsUtils Utility API as a fluent API.</p> <p>Both have nearly the same behaviour when it comes to processing messages from the batch:</p> <ul> <li>Entire batch has been successfully processed, where your Lambda handler returned successfully, we will let SQS delete the batch to optimize your cost</li> <li>Entire Batch has been partially processed successfully, where exceptions were raised within your <code>SqsMessageHandler</code> interface implementation, we will:<ul> <li>1) Delete successfully processed messages from the queue by directly calling <code>sqs:DeleteMessageBatch</code></li> <li>2) Raise <code>SQSBatchProcessingException</code> to ensure failed messages return to your SQS queue</li> </ul> </li> </ul> <p>The only difference is that SqsUtils Utility API will give you access to return from the processed messages if you need. Exception <code>SQSBatchProcessingException</code> thrown from the utility will have access to both successful and failed messaged along with failure exceptions.</p>"},{"location":"utilities/batch/#functional-interface-sqsmessagehandler","title":"Functional Interface SqsMessageHandler","text":"<p>Both annotation and SqsUtils Utility API requires an implementation of functional interface <code>SqsMessageHandler</code>.</p> <p>This implementation is responsible for processing each individual message from the batch, and to raise an exception if unable to process any of the messages sent.</p> <p>Any non-exception/successful return from your record handler function will instruct utility to queue up each individual message for deletion.</p>"},{"location":"utilities/batch/#sqsbatch-annotation","title":"SqsBatch annotation","text":"<p>When using this annotation, you need provide a class implementation of <code>SqsMessageHandler</code> that will process individual messages from the batch - It should raise an exception if it is unable to process the record.</p> <p>All records in the batch will be passed to this handler for processing, even if exceptions are thrown - Here's the behaviour after completing the batch:</p> <ul> <li>Any successfully processed messages, we will delete them from the queue via <code>sqs:DeleteMessageBatch</code></li> <li>Any unprocessed messages detected, we will raise <code>SQSBatchProcessingException</code> to ensure failed messages return to your SQS queue</li> </ul> <p>Warning</p> <p>You will not have access to the processed messages within the Lambda Handler - all processing logic will and should be performed by the implemented <code>SqsMessageHandler#process()</code> function.</p> AppSqsEvent.java <pre><code>public class AppSqsEvent implements RequestHandler&lt;SQSEvent, String&gt; {\n@Override\n@SqsBatch(SampleMessageHandler.class)\npublic String handleRequest(SQSEvent input, Context context) {\nreturn \"{\\\"statusCode\\\": 200}\";\n}\n\npublic class SampleMessageHandler implements SqsMessageHandler&lt;Object&gt; {\n\n@Override\npublic String process(SQSMessage message) {\n// This will be called for each individual message from a batch\n// It should raise an exception if the message was not processed successfully\nString returnVal = doSomething(message.getBody());\nreturn returnVal;\n}\n}\n}\n</code></pre>"},{"location":"utilities/batch/#sqsutils-utility-api","title":"SqsUtils Utility API","text":"<p>If you require access to the result of processed messages, you can use this utility. The result from calling <code>SqsUtils#batchProcessor()</code> on the context manager will be a list of all the return values  from your <code>SqsMessageHandler#process()</code> function.</p> <p>You can also use the utility in functional way by providing inline implementation of functional interface <code>SqsMessageHandler#process()</code></p> Utility API <pre><code>public class AppSqsEvent implements RequestHandler&lt;SQSEvent, List&lt;String&gt;&gt; {\n@Override\npublic List&lt;String&gt; handleRequest(SQSEvent input, Context context) {\nList&lt;String&gt; returnValues = SqsUtils.batchProcessor(input, SampleMessageHandler.class);\nreturn returnValues;\n}\n\npublic class SampleMessageHandler implements SqsMessageHandler&lt;String&gt; {\n\n@Override\npublic String process(SQSMessage message) {\n// This will be called for each individual message from a batch\n// It should raise an exception if the message was not processed successfully\nString returnVal = doSomething(message.getBody());\nreturn returnVal;\n}\n}\n}\n</code></pre> Function implementation <pre><code>public class AppSqsEvent implements RequestHandler&lt;SQSEvent, List&lt;String&gt;&gt; {\n\n@Override\npublic List&lt;String&gt; handleRequest(SQSEvent input, Context context) {\nList&lt;String&gt; returnValues = SqsUtils.batchProcessor(input, (message) -&gt; {\n// This will be called for each individual message from a batch\n// It should raise an exception if the message was not processed successfully\nString returnVal = doSomething(message.getBody());\nreturn returnVal;\n});\nreturn returnValues;\n}\n}\n</code></pre>"},{"location":"utilities/batch/#passing-custom-sqsclient","title":"Passing custom SqsClient","text":"<p>If you need to pass custom SqsClient such as region to the SDK, you can pass your own <code>SqsClient</code> to be used by utility either for SqsBatch annotation, or SqsUtils Utility API.</p> App.java <pre><code>public class AppSqsEvent implements RequestHandler&lt;SQSEvent, List&lt;String&gt;&gt; {\nstatic {\nSqsUtils.overrideSqsClient(SqsClient.builder()\n.build());\n}\n\n@Override\npublic List&lt;String&gt; handleRequest(SQSEvent input, Context context) {\nList&lt;String&gt; returnValues = SqsUtils.batchProcessor(input, SampleMessageHandler.class);\n\nreturn returnValues;\n}\n\npublic class SampleMessageHandler implements SqsMessageHandler&lt;String&gt; {\n\n@Override\npublic String process(SQSMessage message) {\n// This will be called for each individual message from a batch\n// It should raise an exception if the message was not processed successfully\nString returnVal = doSomething(message.getBody());\nreturn returnVal;\n}\n}\n}\n</code></pre>"},{"location":"utilities/batch/#suppressing-exceptions","title":"Suppressing exceptions","text":"<p>If you want to disable the default behavior where <code>SQSBatchProcessingException</code> is raised if there are any exception, you can pass the <code>suppressException</code> boolean argument.</p> Within SqsBatch annotation <pre><code>    @Override\n@SqsBatch(value = SampleMessageHandler.class, suppressException = true)\npublic String handleRequest(SQSEvent input, Context context) {\nreturn \"{\\\"statusCode\\\": 200}\";\n}\n</code></pre> Within SqsUtils Utility API <pre><code>    @Override\npublic List&lt;String&gt; handleRequest(SQSEvent input, Context context) {\nList&lt;String&gt; returnValues = SqsUtils.batchProcessor(input, true, SampleMessageHandler.class);\nreturn returnValues;\n}\n</code></pre>"},{"location":"utilities/parameters/","title":"Parameters","text":"<p>The parameters utility provides a way to retrieve parameter values from AWS Systems Manager Parameter Store or AWS Secrets Manager. It also provides a base class to create your parameter provider implementation.</p> <p>Key features</p> <ul> <li>Retrieve one or multiple parameters from the underlying provider</li> <li>Cache parameter values for a given amount of time (defaults to 5 seconds)</li> <li>Transform parameter values from JSON or base 64 encoded strings</li> </ul>"},{"location":"utilities/parameters/#install","title":"Install","text":"<p>To install this utility, add the following dependency to your project.</p> Maven <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-parameters&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> Gradle <pre><code> dependencies {\n...\nimplementation 'software.amazon.lambda:powertools-parameters:1.3.0'\naspectpath 'software.amazon.lambda:powertools-parameters:1.3.0'\n}\n</code></pre> <p>IAM Permissions</p> <p>This utility requires additional permissions to work as expected. See the table below:</p> Provider Function/Method IAM Permission SSM Parameter Store <code>SSMProvider.get(String)</code> <code>SSMProvider.get(String, Class)</code> <code>ssm:GetParameter</code> SSM Parameter Store <code>SSMProvider.getMultiple(String)</code> <code>ssm:GetParametersByPath</code> Secrets Manager <code>SecretsProvider.get(String)</code> <code>SecretsProvider.get(String, Class)</code> <code>secretsmanager:GetSecretValue</code>"},{"location":"utilities/parameters/#ssm-parameter-store","title":"SSM Parameter Store","text":"<p>You can retrieve a single parameter using SSMProvider.get() and pass the key of the parameter. For multiple parameters, you can use SSMProvider.getMultiple() and pass the path to retrieve them all.</p> <p>Alternatively, you can retrieve an instance of a provider and configure its underlying SDK client, in order to get data from other regions or use specific credentials.</p> SSMProvider <pre><code>import software.amazon.lambda.powertools.parameters.SSMProvider;\nimport software.amazon.lambda.powertools.parameters.ParamManager;\n\npublic class AppWithSSM implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n// Get an instance of the SSM Provider\nSSMProvider ssmProvider = ParamManager.getSsmProvider();\n// Retrieve a single parameter\nString value = ssmProvider.get(\"/my/parameter\");\n\n// Retrieve multiple parameters from a path prefix\n// This returns a Map with the parameter name as key\nMap&lt;String, String&gt; values = ssmProvider.getMultiple(\"/my/path/prefix\");\n\n}\n</code></pre> SSMProvider with an explicit region <pre><code>import software.amazon.lambda.powertools.parameters.SSMProvider;\nimport software.amazon.lambda.powertools.parameters.ParamManager;\n\npublic class AppWithSSM implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\nSsmClient client = SsmClient.builder().region(Region.EU_CENTRAL_1).build();\n// Get an instance of the SSM Provider\nSSMProvider ssmProvider = ParamManager.getSsmProvider(client);\n// Retrieve a single parameter\nString value = ssmProvider.get(\"/my/parameter\");\n\n// Retrieve multiple parameters from a path prefix\n// This returns a Map with the parameter name as key\nMap&lt;String, String&gt; values = ssmProvider.getMultiple(\"/my/path/prefix\");\n\n}\n</code></pre>"},{"location":"utilities/parameters/#additional-arguments","title":"Additional arguments","text":"<p>The AWS Systems Manager Parameter Store provider supports two additional arguments for the <code>get()</code> and <code>getMultiple()</code> methods:</p> Option Default Description withDecryption() <code>False</code> Will automatically decrypt the parameter. recursive() <code>False</code> For <code>getMultiple()</code> only, will fetch all parameter values recursively based on a path prefix. <p>Example:</p> AppWithSSM.java <pre><code>import software.amazon.lambda.powertools.parameters.SSMProvider;\nimport software.amazon.lambda.powertools.parameters.ParamManager;\n\npublic class AppWithSSM implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n// Get an instance of the SSM Provider\nSSMProvider ssmProvider = ParamManager.getSsmProvider();\n\n// Retrieve a single parameter and decrypt it\nString value = ssmProvider.withDecryption().get(\"/my/parameter\");\n// Retrieve multiple parameters recursively from a path prefix\nMap&lt;String, String&gt; values = ssmProvider.recursive().getMultiple(\"/my/path/prefix\");\n}\n</code></pre>"},{"location":"utilities/parameters/#secrets-manager","title":"Secrets Manager","text":"<p>For secrets stored in Secrets Manager, use <code>getSecretsProvider</code>.</p> <p>Alternatively, you can retrieve an instance of a provider and configure its underlying SDK client, in order to get data from other regions or use specific credentials.</p> SecretsProvider <pre><code>import software.amazon.lambda.powertools.parameters.SecretsProvider;\nimport software.amazon.lambda.powertools.parameters.ParamManager;\n\npublic class AppWithSecrets implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n// Get an instance of the Secrets Provider\nSecretsProvider secretsProvider = ParamManager.getSecretsProvider();\n\n// Retrieve a single secret\nString value = secretsProvider.get(\"/my/secret\");\n}\n</code></pre> SecretsProvider with an explicit region <pre><code>import software.amazon.lambda.powertools.parameters.SecretsProvider;\nimport software.amazon.lambda.powertools.parameters.ParamManager;\n\npublic class AppWithSecrets implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\nSecretsManagerClient client = SecretsManagerClient.builder().region(Region.EU_CENTRAL_1).build();\n// Get an instance of the Secrets Provider\nSecretsProvider secretsProvider = ParamManager.getSecretsProvider(client);\n// Retrieve a single secret\nString value = secretsProvider.get(\"/my/secret\");\n\n}\n</code></pre>"},{"location":"utilities/parameters/#advanced-configuration","title":"Advanced configuration","text":""},{"location":"utilities/parameters/#caching","title":"Caching","text":"<p>By default, all parameters and their corresponding values are cached for 5 seconds.</p> <p>You can customize this default value using <code>defaultMaxAge</code>. You can also customize this value for each parameter using  <code>withMaxAge</code>.</p> Provider with default Max age <pre><code>import software.amazon.lambda.powertools.parameters.SecretsProvider;\nimport software.amazon.lambda.powertools.parameters.ParamManager;\n\npublic class AppWithSecrets implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n// Get an instance of the Secrets Provider\nSecretsProvider secretsProvider = ParamManager.getSecretsProvider()\n.defaultMaxAge(10, ChronoUnit.SECONDS);\n\nString value = secretsProvider.get(\"/my/secret\");\n}\n</code></pre> Provider with age for each param <pre><code>import software.amazon.lambda.powertools.parameters.SecretsProvider;\nimport software.amazon.lambda.powertools.parameters.ParamManager;\n\npublic class AppWithSecrets implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\nSecretsManagerClient client = SecretsManagerClient.builder().region(Region.EU_CENTRAL_1).build();\n\nSecretsProvider secretsProvider = ParamManager.getSecretsProvider(client);\nString value = secretsProvider.withMaxAge(10, ChronoUnit.SECONDS).get(\"/my/secret\");\n\n}\n</code></pre>"},{"location":"utilities/parameters/#transform-values","title":"Transform values","text":"<p>Parameter values can be transformed using <code>withTransformation(transformerClass)</code>. Base64 and JSON transformations are provided. For more complex transformation, you need to specify how to deserialize-</p> <p><code>SSMProvider.getMultiple()</code> does not support transformation and will return simple Strings.</p> Base64 Transformation <pre><code>   String value = provider\n.withTransformation(Transformer.base64)\n.get(\"/my/parameter/b64\");\n</code></pre> Complex Transformation <pre><code>   MyObj object = provider\n.withTransformation(Transformer.json)\n.get(\"/my/parameter/json\", MyObj.class);\n</code></pre>"},{"location":"utilities/parameters/#write-your-own-transformer","title":"Write your own Transformer","text":"<p>You can write your own transformer, by implementing the <code>Transformer</code> interface and the <code>applyTransformation()</code> method. For example, if you wish to deserialize XML into an object.</p> XmlTransformer.java <pre><code>public class XmlTransformer&lt;T&gt; implements Transformer&lt;T&gt; {\nprivate final XmlMapper mapper = new XmlMapper();\n\n@Override\npublic T applyTransformation(String value, Class&lt;T&gt; targetClass) throws TransformationException {\ntry {\nreturn mapper.readValue(value, targetClass);\n} catch (IOException e) {\nthrow new TransformationException(e);\n}\n}\n}\n</code></pre> Using XmlTransformer <pre><code>    MyObj object = provider\n.withTransformation(XmlTransformer.class)\n.get(\"/my/parameter/xml\", MyObj.class);\n</code></pre>"},{"location":"utilities/parameters/#fluent-api","title":"Fluent API","text":"<p>To simplify the use of the library, you can chain all method calls before a get.</p> Fluent API call <pre><code>    ssmProvider\n.defaultMaxAge(10, SECONDS)     // will set 10 seconds as the default cache TTL\n.withMaxAge(1, MINUTES)         // will set the cache TTL for this value at 1 minute\n.withTransformation(json)       // json is a static import from Transformer.json\n.withDecryption()               // enable decryption of the parameter value\n.get(\"/my/param\", MyObj.class); // finally get the value\n</code></pre>"},{"location":"utilities/parameters/#create-your-own-provider","title":"Create your own provider","text":"<p>You can create your own custom parameter store provider by inheriting the <code>BaseProvider</code> class and implementing the <code>String getValue(String key)</code> method to retrieve data from your underlying store. All transformation and caching logic is handled by the get() methods in the base class.</p> Example implementation using S3 as a custom parameter <pre><code>public class S3Provider extends BaseProvider {\n\nprivate final S3Client client;\nprivate String bucket;\n\nS3Provider(CacheManager cacheManager) {\nthis(cacheManager, S3Client.create());\n}\n\nS3Provider(CacheManager cacheManager, S3Client client) {\nsuper(cacheManager);\nthis.client = client;\n}\n\npublic S3Provider withBucket(String bucket) {\nthis.bucket = bucket;\nreturn this;\n}\n\n@Override\nprotected String getValue(String key) {\nif (bucket == null) {\nthrow new IllegalStateException(\"A bucket must be specified, using withBucket() method\");\n}\n\nGetObjectRequest request = GetObjectRequest.builder().bucket(bucket).key(key).build();\nResponseBytes&lt;GetObjectResponse&gt; response = client.getObject(request, ResponseTransformer.toBytes());\nreturn response.asUtf8String();\n}\n\n@Override\nprotected Map&lt;String, String&gt; getMultipleValues(String path) {\nif (bucket == null) {\nthrow new IllegalStateException(\"A bucket must be specified, using withBucket() method\");\n}\n\nListObjectsV2Request listRequest = ListObjectsV2Request.builder().bucket(bucket).prefix(path).build();\nList&lt;S3Object&gt; s3Objects = client.listObjectsV2(listRequest).contents();\n\nMap&lt;String, String&gt; result = new HashMap&lt;&gt;();\ns3Objects.forEach(s3Object -&gt; {\nresult.put(s3Object.key(), getValue(s3Object.key()));\n});\n\nreturn result;\n}\n\n@Override\nprotected void resetToDefaults() {\nsuper.resetToDefaults();\nbucket = null;\n}\n\n}\n</code></pre> Using custom parameter store <pre><code>    S3Provider provider = new S3Provider(ParamManager.getCacheManager());\n\nprovider.setTransformationManager(ParamManager.getTransformationManager());\nString value = provider.withBucket(\"myBucket\").get(\"myKey\");\n</code></pre>"},{"location":"utilities/parameters/#annotation","title":"Annotation","text":"<p>You can make use of the annotation <code>@Param</code> to inject a parameter value in a variable.</p> <p>By default, it will use <code>SSMProvider</code> to retrieve the value from AWS System Manager Parameter Store. You could specify a different provider as long as it extends <code>BaseProvider</code> and/or a <code>Transformer</code>.</p> Param Annotation <pre><code>public class AppWithAnnotation implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Param(key = \"/my/parameter/json\")\nObjectToDeserialize value;\n\n}\n</code></pre> Custom Provider Usage <pre><code>public class AppWithAnnotation implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Param(key = \"/my/parameter/json\" provider = SecretsProvider.class, transformer = JsonTransformer.class)\nObjectToDeserialize value;\n\n}\n</code></pre> <p>In this case <code>SecretsProvider</code> will be used to retrieve a raw value that is then trasformed into the target Object by using <code>JsonTransformer</code>. To show the convenience of the annotation compare the following two code snippets.</p>"},{"location":"utilities/parameters/#install_1","title":"Install","text":"<p>If you want to use the <code>@Param</code> annotation in your project add configuration to compile-time weave (CTW) the powertools-parameters aspects into your project.</p> Maven <pre><code>&lt;build&gt;\n&lt;plugins&gt;\n...\n        &lt;plugin&gt;\n&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n&lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;1.11&lt;/version&gt;\n&lt;configuration&gt;\n...\n                 &lt;aspectLibraries&gt;\n...\n                     &lt;aspectLibrary&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-parameters&lt;/artifactId&gt;\n&lt;/aspectLibrary&gt;\n&lt;/aspectLibraries&gt;\n&lt;/configuration&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;goals&gt;\n&lt;goal&gt;compile&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n...\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <p>Note: If you are working with lambda function on runtime post java8, please refer issue for workaround</p> Gradle <pre><code>plugins{\nid 'java'\nid 'aspectj.AspectjGradlePlugin' version '0.0.6'\n}\nrepositories {\njcenter()\n}\ndependencies {\n...\nimplementation 'software.amazon.lambda:powertools-parameters:1.3.0'\naspectpath 'software.amazon.lambda:powertools-parameters:1.3.0'\n}\n</code></pre> <p>Note:</p> <p>Please add <code>aspectjVersion = '1.9.6'</code> to the <code>gradle.properties</code> file. The aspectj plugin works at the moment with gradle 5.x only if you are using <code>java 8</code> as runtime. Please refer to open issue for more details.</p>"},{"location":"utilities/sqs_large_message_handling/","title":"SQS Large Message Handling","text":"<p>The large message handling utility handles SQS messages which have had their payloads offloaded to S3 due to them being larger than the SQS maximum.</p> <p>The utility automatically retrieves messages which have been offloaded to S3 using the amazon-sqs-java-extended-client-lib client library. Once the message payloads have been processed successful the utility can delete the message payloads from S3.</p> <p>This utility is compatible with versions 1.1.0+ of amazon-sqs-java-extended-client-lib.</p> Maven <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.amazonaws&lt;/groupId&gt;\n&lt;artifactId&gt;amazon-sqs-java-extended-client-lib&lt;/artifactId&gt;\n&lt;version&gt;1.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> Gradle <pre><code> dependencies {\nimplementation 'com.amazonaws:amazon-sqs-java-extended-client-lib:1.1.0'\n}\n</code></pre>"},{"location":"utilities/sqs_large_message_handling/#install","title":"Install","text":"<p>To install this utility, add the following dependency to your project.</p> <p>Using Java 9 or later?</p> <p>If you are working with lambda function on runtime Java 9 or later, please refer issue for a workaround.</p> Maven <pre><code>&lt;dependencies&gt;\n...\n    &lt;dependency&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-sqs&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n&lt;!-- configure the aspectj-maven-plugin to compile-time weave (CTW) the aws-lambda-powertools-java aspects into your project --&gt;\n&lt;build&gt;\n&lt;plugins&gt;\n...\n        &lt;plugin&gt;\n&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n&lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;1.11&lt;/version&gt;\n&lt;configuration&gt;\n&lt;source&gt;1.8&lt;/source&gt;\n&lt;target&gt;1.8&lt;/target&gt;\n&lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt;\n&lt;aspectLibraries&gt;\n&lt;aspectLibrary&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-sqs&lt;/artifactId&gt;\n&lt;/aspectLibrary&gt;\n&lt;/aspectLibraries&gt;\n&lt;/configuration&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;goals&gt;\n&lt;goal&gt;compile&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n...\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> Gradle <pre><code> dependencies {\n...\nimplementation 'software.amazon.lambda:powertools-sqs:1.3.0'\naspectpath 'software.amazon.lambda:powertools-sqs:1.3.0'\n}\n</code></pre>"},{"location":"utilities/sqs_large_message_handling/#lambda-handler","title":"Lambda handler","text":"<p>The annotation <code>@SqsLargeMessage</code> should be used with the handleRequest method of a class which implements <code>com.amazonaws.services.lambda.runtime.RequestHandler</code> with <code>com.amazonaws.services.lambda.runtime.events.SQSEvent</code> as the first parameter.</p> SqsMessageHandler.java <pre><code>import software.amazon.lambda.powertools.sqs.SqsLargeMessage;\n\npublic class SqsMessageHandler implements RequestHandler&lt;SQSEvent, String&gt; {\n\n@Override\n@SqsLargeMessage\npublic String handleRequest(SQSEvent sqsEvent, Context context) {\n// process messages\n\nreturn \"ok\";\n}\n}\n</code></pre> <p><code>@SqsLargeMessage</code> creates a default S3 Client <code>AmazonS3 amazonS3 = AmazonS3ClientBuilder.defaultClient()</code>.</p> <p>Tip</p> <p>When the Lambda function is invoked with an event from SQS, each received record in the SQSEvent is checked to see to validate if it is offloaded to S3. If it does then <code>getObject(bucket, key)</code> will be called, and the payload retrieved.  If there is an error during this process then the function will fail with a <code>FailedProcessingLargePayloadException</code> exception.</p> <p>If the request handler method returns without error then each payload will be deleted from S3 using <code>deleteObject(bucket, key)</code></p> <p>To disable deletion of payloads setting the following annotation parameter:</p> Disable payload deletion <pre><code>import software.amazon.lambda.powertools.sqs.SqsLargeMessage;\n\n@SqsLargeMessage(deletePayloads=false)\npublic class SqsMessageHandler implements RequestHandler&lt;SQSEvent, String&gt; {\n\n}\n</code></pre>"},{"location":"utilities/sqs_large_message_handling/#utility","title":"Utility","text":"<p>If you want to avoid using annotation and have control over error that can happen during payload enrichment use <code>SqsUtils.enrichedMessageFromS3()</code>. It provides you access with list of <code>SQSMessage</code> object enriched from S3 payload.</p> <p>Original <code>SQSEvent</code> object is never mutated. You can also control if the S3 payload should be deleted after successful processing.</p> Functional API without annotation <pre><code>import software.amazon.lambda.powertools.sqs.SqsLargeMessage;\nimport software.amazon.lambda.powertools.sqs.SqsUtils;\n\npublic class SqsMessageHandler implements RequestHandler&lt;SQSEvent, String&gt; {\n\n@Override\npublic String handleRequest(SQSEvent sqsEvent, Context context) {\n\nMap&lt;String, String&gt; sqsMessage = SqsUtils.enrichedMessageFromS3(sqsEvent, sqsMessages -&gt; {\n// Some business logic\nMap&lt;String, String&gt; someBusinessLogic = new HashMap&lt;&gt;();\nsomeBusinessLogic.put(\"Message\", sqsMessages.get(0).getBody());\nreturn someBusinessLogic;\n});\n// Do not delete payload after processing.\nMap&lt;String, String&gt; sqsMessage = SqsUtils.enrichedMessageFromS3(sqsEvent, false, sqsMessages -&gt; {\n// Some business logic\nMap&lt;String, String&gt; someBusinessLogic = new HashMap&lt;&gt;();\nsomeBusinessLogic.put(\"Message\", sqsMessages.get(0).getBody());\nreturn someBusinessLogic;\n});\n// Better control over exception during enrichment\ntry {\n// Do not delete payload after processing.\nSqsUtils.enrichedMessageFromS3(sqsEvent, false, sqsMessages -&gt; {\n// Some business logic\n});\n} catch (FailedProcessingLargePayloadException e) {\n// handle any exception.\n}\n\nreturn \"ok\";\n}\n}\n</code></pre>"},{"location":"utilities/validation/","title":"Validation","text":"<p>This utility provides JSON Schema validation for payloads held within events and response used in AWS Lambda.</p> <p>Key features</p> <ul> <li>Validate incoming events and responses</li> <li>Built-in validation for most common events (API Gateway, SNS, SQS, ...)</li> <li>JMESPath support validate only a sub part of the event</li> </ul>"},{"location":"utilities/validation/#install","title":"Install","text":"<p>To install this utility, add the following dependency to your project.</p> <p>Using Java 9 or later?</p> <p>If you are working with lambda function on runtime Java 9 or later, please refer issue for a workaround.</p> Maven <pre><code>&lt;dependencies&gt;\n...\n&lt;dependency&gt;\n&lt;groupId&gt;com.amazonaws&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-validation&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n...\n&lt;/dependencies&gt;\n&lt;!-- configure the aspectj-maven-plugin to compile-time weave (CTW) the aws-lambda-powertools-java aspects into your project --&gt;\n&lt;build&gt;\n&lt;plugins&gt;\n...\n        &lt;plugin&gt;\n&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n&lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;1.11&lt;/version&gt;\n&lt;configuration&gt;\n&lt;source&gt;1.8&lt;/source&gt;\n&lt;target&gt;1.8&lt;/target&gt;\n&lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt;\n&lt;aspectLibraries&gt;\n&lt;aspectLibrary&gt;\n&lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt;\n&lt;artifactId&gt;powertools-validation&lt;/artifactId&gt;\n&lt;/aspectLibrary&gt;\n&lt;/aspectLibraries&gt;\n&lt;/configuration&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;goals&gt;\n&lt;goal&gt;compile&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n...\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> Gradle <pre><code> dependencies {\nimplementation 'software.amazon.lambda:powertools-validation:1.3.0'\naspectpath 'software.amazon.lambda:powertools-validation:1.3.0'\n}\n</code></pre>"},{"location":"utilities/validation/#validating-events","title":"Validating events","text":"<p>You can validate inbound and outbound events using <code>@Validation</code> annotation.</p> <p>You can also use the <code>Validator#validate()</code> methods, if you want more control over the validation process such as handling a validation error.</p> <p>We support JSON schema version 4, 6, 7 and 201909 (from jmespath-jackson library).</p>"},{"location":"utilities/validation/#validation-annotation","title":"Validation annotation","text":"<p><code>@Validation</code> annotation is used to validate either inbound events or functions' response.</p> <p>It will fail fast with <code>ValidationException</code> if an event or response doesn't conform with given JSON Schema.</p> <p>While it is easier to specify a json schema file in the classpath (using the notation <code>\"classpath:/path/to/schema.json\"</code>), you can also provide a JSON String containing the schema.</p> MyFunctionHandler.java <pre><code>import software.amazon.lambda.powertools.validation.Validation;\n\npublic class MyFunctionHandler implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Override\n@Validation(inboundSchema = \"classpath:/schema_in.json\", outboundSchema = \"classpath:/schema_out.json\")\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\n// ...\nreturn something;\n}\n}\n</code></pre> <p>NOTE: It's not a requirement to validate both inbound and outbound schemas - You can either use one, or both.</p>"},{"location":"utilities/validation/#validate-function","title":"Validate function","text":"<p>Validate standalone function is used within the Lambda handler, or any other methods that perform data validation.</p> <p>You can also gracefully handle schema validation errors by catching <code>ValidationException</code>.</p> MyFunctionHandler.java <pre><code>import static software.amazon.lambda.powertools.validation.ValidationUtils.*;\n\npublic class MyFunctionHandler implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; {\n\n@Override\npublic APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {\ntry {\nvalidate(input, \"classpath:/schema.json\");\n} catch (ValidationException ex) {\n// do something before throwing it\nthrow ex;\n}\n\n// ...\nreturn something;\n}\n}\n</code></pre> <p>NOTE: Schemas are stored in memory for reuse, to avoid loading them from file each time.</p>"},{"location":"utilities/validation/#built-in-events-and-responses","title":"Built-in events and responses","text":"<p>For the following events and responses, the Validator will automatically perform validation on the content.</p> <p> Events </p> Type of event Class Path to content API Gateway REST APIGatewayProxyRequestEvent <code>body</code> API Gateway HTTP APIGatewayV2HTTPEvent <code>body</code> Application Load Balancer ApplicationLoadBalancerRequestEvent <code>body</code> Cloudformation Custom Resource CloudFormationCustomResourceEvent <code>resourceProperties</code> CloudWatch Logs CloudWatchLogsEvent <code>awslogs.powertools_base64_gzip(data)</code> EventBridge / Cloudwatch ScheduledEvent <code>detail</code> Kafka KafkaEvent <code>records[*][*].value</code> Kinesis KinesisEvent <code>Records[*].kinesis.powertools_base64(data)</code> Kinesis Firehose KinesisFirehoseEvent <code>Records[*].powertools_base64(data)</code> Kinesis Analytics from Firehose KinesisAnalyticsFirehoseInputPreprocessingEvent <code>Records[*].powertools_base64(data)</code> Kinesis Analytics from Streams KinesisAnalyticsStreamsInputPreprocessingEvent <code>Records[*].powertools_base64(data)</code> SNS SNSEvent <code>Records[*].Sns.Message</code> SQS SQSEvent <code>Records[*].body</code> <p> Responses </p> Type of response Class Path to content (envelope) API Gateway REST APIGatewayProxyResponseEvent} <code>body</code> API Gateway HTTP APIGatewayV2HTTPResponse} <code>body</code> API Gateway WebSocket APIGatewayV2WebSocketResponse} <code>body</code> Load Balancer ApplicationLoadBalancerResponseEvent} <code>body</code> Kinesis Analytics KinesisAnalyticsInputPreprocessingResponse} `Records[*].powertools_base64(data)``"},{"location":"utilities/validation/#custom-events-and-responses","title":"Custom events and responses","text":"<p>You can also validate any Event or Response type, once you have the appropriate schema.</p> <p>Sometimes, you might want to validate only a portion of it - This is where the envelope parameter is for.</p> <p>Envelopes are JMESPath expressions to extract a portion of JSON you want before applying JSON Schema validation.</p> MyCustomEventHandler.java <pre><code>import software.amazon.lambda.powertools.validation.Validation;\n\npublic class MyCustomEventHandler implements RequestHandler&lt;MyCustomEvent, String&gt; {\n\n@Override\n@Validation(inboundSchema = \"classpath:/my_custom_event_schema.json\",\nenvelope = \"basket.products[*]\")\npublic String handleRequest(MyCustomEvent input, Context context) {\nreturn \"OK\";\n}\n}\n</code></pre> my_custom_event_schema.json <pre><code>{\n\"basket\": {\n\"products\" : [\n{\n\"id\": 43242,\n\"name\": \"FooBar XY\",\n\"price\": 258\n},\n{\n\"id\": 765,\n\"name\": \"BarBaz AB\",\n\"price\": 43.99\n}\n]\n}\n}\n</code></pre> <p>This is quite powerful because you can use JMESPath Query language to extract records from arrays, slice and dice, to pipe expressions and function expressions, where you'd extract what you need before validating the actual payload.</p>"},{"location":"utilities/validation/#jmespath-functions","title":"JMESPath functions","text":"<p>JMESPath functions ensure to make an operation on a specific part of the json.validate</p> <p>Powertools provides two built-in functions:</p>"},{"location":"utilities/validation/#powertools_base64-function","title":"powertools_base64 function","text":"<p>Use <code>powertools_base64</code> function to decode any base64 data.</p> <p>Below sample will decode the base64 value within the data key, and decode the JSON string into a valid JSON before we can validate it.</p> MyEventHandler.java <pre><code>import software.amazon.lambda.powertools.validation.ValidationUtils;\n\npublic class MyEventHandler implements RequestHandler&lt;MyEvent, String&gt; {\n\n@Override\npublic String handleRequest(MyEvent myEvent, Context context) {\nvalidate(myEvent, \"classpath:/schema.json\", \"powertools_base64(data)\");\nreturn \"OK\";\n}\n}\n</code></pre> schema.json <pre><code>{\n\"data\" : \"ewogICJpZCI6IDQzMjQyLAogICJuYW1lIjogIkZvb0JhciBYWSIsCiAgInByaWNlIjogMjU4Cn0=\"\n}\n</code></pre>"},{"location":"utilities/validation/#powertools_base64_gzip-function","title":"powertools_base64_gzip function","text":"<p>Use <code>powertools_base64_gzip</code> function to decompress and decode base64 data.</p> <p>Below sample will decompress and decode base64 data.</p> MyEventHandler.java <pre><code>import software.amazon.lambda.powertools.validation.ValidationUtils;\n\npublic class MyEventHandler implements RequestHandler&lt;MyEvent, String&gt; {\n\n@Override\npublic String handleRequest(MyEvent myEvent, Context context) {\nvalidate(myEvent, \"classpath:/schema.json\", \"powertools_base64_gzip(data)\");\nreturn \"OK\";\n}\n}\n</code></pre> schema.json <pre><code>{\n\"data\" : \"H4sIAAAAAAAA/6vmUlBQykxRslIwMTYyMdIBcfMSc1OBAkpu+flOiUUKEZFKYOGCosxkkLiRqQVXLQDnWo6bOAAAAA==\"\n}\n</code></pre> <p>Note</p> <p>You don't need any function to transform a JSON String into a JSON object, powertools-validation will do it for you. In the 2 previous example, data contains JSON. Just provide the function to transform the base64 / gzipped / ... string into a clear JSON string.</p>"},{"location":"utilities/validation/#bring-your-own-jmespath-function","title":"Bring your own JMESPath function","text":"<p>Warning</p> <p>This should only be used for advanced use cases where you have special formats not covered by the built-in functions. New functions will be added to the 2 built-in ones.</p> <p>Your function must extend <code>io.burt.jmespath.function.BaseFunction</code>, take a String as parameter and return a String. You can read the doc for more information.</p> <p>Below is an example that takes some xml and transform it into json. Once your function is created, you need to add it  to powertools.You can then use it to do your validation or using annotation.</p> XMLFunction.java <pre><code>public class XMLFunction extends BaseFunction {\npublic Base64Function() {\nsuper(\"powertools_xml\", ArgumentConstraints.typeOf(JmesPathType.STRING));\n}\n\n@Override\nprotected &lt;T&gt; T callFunction(Adapter&lt;T&gt; runtime, List&lt;FunctionArgument&lt;T&gt;&gt; arguments) {\nT value = arguments.get(0).value();\nString xmlString = runtime.toString(value);\n\nString jsonString =  // ... transform xmlString to json\n\nreturn runtime.createString(jsonString);\n}\n}\n</code></pre> Handler with validation API <pre><code>...\nimport software.amazon.lambda.powertools.validation.ValidationConfig;\nimport software.amazon.lambda.powertools.validation.ValidationUtils.validate;\n\nstatic {\nValidationConfig.get().addFunction(new XMLFunction());\n}\n\npublic class MyXMLEventHandler implements RequestHandler&lt;MyEventWithXML, String&gt; {\n\n@Override\npublic String handleRequest(MyEventWithXML myEvent, Context context) {\nvalidate(myEvent, \"classpath:/schema.json\", \"powertools_xml(path.to.xml_data)\");\nreturn \"OK\";\n}\n}\n</code></pre> Handler with validation annotation <pre><code>...\nimport software.amazon.lambda.powertools.validation.ValidationConfig;\nimport software.amazon.lambda.powertools.validation.Validation;\n\nstatic {\nValidationConfig.get().addFunction(new XMLFunction());\n}\n\npublic class MyXMLEventHandler implements RequestHandler&lt;MyEventWithXML, String&gt; {\n\n@Override\n@Validation(inboundSchema=\"classpath:/schema.json\", envelope=\"powertools_xml(path.to.xml_data)\")\npublic String handleRequest(MyEventWithXML myEvent, Context context) {\nreturn \"OK\";\n}\n}\n</code></pre>"},{"location":"utilities/validation/#change-the-schema-version","title":"Change the schema version","text":"<p>By default, powertools-validation is configured with V7. You can use the <code>ValidationConfig</code> to change that behaviour.</p> Handler with custom schema version <pre><code>...\nimport software.amazon.lambda.powertools.validation.ValidationConfig;\nimport software.amazon.lambda.powertools.validation.Validation;\n\nstatic {\nValidationConfig.get().setSchemaVersion(SpecVersion.VersionFlag.V4);\n}\n\npublic class MyXMLEventHandler implements RequestHandler&lt;MyEventWithXML, String&gt; {\n\n@Override\n@Validation(inboundSchema=\"classpath:/schema.json\", envelope=\"powertools_xml(path.to.xml_data)\")\npublic String handleRequest(MyEventWithXML myEvent, Context context) {\nreturn \"OK\";\n}\n}\n</code></pre>"},{"location":"utilities/validation/#advanced-objectmapper-settings","title":"Advanced ObjectMapper settings","text":"<p>If you need to configure the Jackson ObjectMapper, you can use the <code>ValidationConfig</code>:</p> Handler with custom ObjectMapper <pre><code>...\nimport software.amazon.lambda.powertools.validation.ValidationConfig;\nimport software.amazon.lambda.powertools.validation.Validation;\n\nstatic {\nObjectMapper objectMapper= ValidationConfig.get().getObjectMapper();\n// update (de)serializationConfig or other properties\n}\n\npublic class MyXMLEventHandler implements RequestHandler&lt;MyEventWithXML, String&gt; {\n\n@Override\n@Validation(inboundSchema=\"classpath:/schema.json\", envelope=\"powertools_xml(path.to.xml_data)\")\npublic String handleRequest(MyEventWithXML myEvent, Context context) {\nreturn \"OK\";\n}\n}\n</code></pre>"}]}